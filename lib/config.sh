#!/bin/bash

# üìÅ Dreamcoder Setup - Gesti√≥n de Configuraciones
# Instalaci√≥n y gesti√≥n de archivos de configuraci√≥n

# Verificar si ya fue cargado
if [[ "${DREAMCODER_CONFIG_LOADED:-}" == "true" ]]; then
    return 0
fi
DREAMCODER_CONFIG_LOADED=true

# ================================
# CONFIGURACIONES DISPONIBLES
# ================================
declare -A CONFIGS=(
    ["zsh"]="zshrc/.zshrc|$HOME/.zshrc|Configuraci√≥n de ZSH usuario|shell"
    ["zsh-root"]="zshrc/root_example.zsh|/root/.zshrc|Configuraci√≥n de ZSH para root|shell"
    ["bash"]="bashrc/.bashrc|$HOME/.bashrc|Configuraci√≥n de Bash|shell"
    ["kitty"]="kitty|$HOME/.config/kitty|Terminal Kitty|terminal"
    ["fastfetch"]="fastfetch|$HOME/.config/fastfetch|Fastfetch con im√°genes|system"
    ["nano"]="nano/nanorc|$HOME/.nanorc|Editor Nano|editor"
    ["starship"]="starship.toml|$HOME/.config/starship.toml|Prompt Starship usuario|prompt"
    ["starship-root"]="starship/starship_root.toml|/root/.config/starship.toml|Prompt Starship para root|prompt"
)

# ================================
# FUNCIONES DE CONFIGURACI√ìN
# ================================
load_config_definitions() {
    local config_file="$CONFIG_DIR/configs.conf"
    
    if [[ -f "$config_file" ]]; then
        print_info "Cargando definiciones de configuraci√≥n desde archivo"
        
        while IFS='=' read -r key value; do
            # Ignorar l√≠neas vac√≠as y comentarios
            if [[ -n "$key" && ! "$key" =~ ^[[:space:]]*# ]]; then
                CONFIGS["$key"]="$value"
            fi
        done < "$config_file"
        
        log_info "Definiciones de configuraci√≥n cargadas desde: $config_file"
    else
        log_info "Usando definiciones de configuraci√≥n por defecto"
    fi
}

install_config() {
    local config_name="$1"
    local source_path="$2"
    local dest_path="$3"
    local description="$4"

    # Validar y sanitizar rutas
    source_path=$(sanitize_path "$source_path") || {
        print_error "Ruta fuente inv√°lida: $2"
        return 1
    }

    dest_path=$(sanitize_path "$dest_path") || {
        print_error "Ruta destino inv√°lida: $3"
        return 1
    }

    # Expandir ~ a la ruta completa del home de forma segura
    if [[ "$dest_path" == \~* ]]; then
        dest_path="${dest_path/#\~/$HOME}"
    fi

    # Verificar que las rutas no contengan caracteres peligrosos despu√©s de expansi√≥n
    if [[ "$dest_path" =~ \.\. || "$source_path" =~ \.\. ]]; then
        print_error "Rutas contienen secuencias peligrosas (..)"
        log_error "Intento de path traversal detectado: $source_path -> $dest_path"
        return 1
    fi

    if [[ ! -f "$source_path" && ! -d "$source_path" ]]; then
        print_warning "Configuraci√≥n no encontrada: $source_path"
        log_warn "Archivo/directorio de configuraci√≥n no encontrado: $source_path"
        return 1
    fi
    
    print_substep "Instalando $description"
    log_info "Instalando configuraci√≥n: $config_name ($source_path -> $dest_path)"
    
    # Detectar si es una configuraci√≥n de root
    local needs_sudo=false
    if [[ "$dest_path" == /root/* ]]; then
        needs_sudo=true
        print_info "Configuraci√≥n requiere permisos de root"
    fi
    
    # Preparar directorio destino
    local dest_dir
    if [[ -d "$source_path" ]]; then
        # Para directorios, el destino es la carpeta completa
        dest_dir="$dest_path"
    else
        # Para archivos, usar el directorio contenedor
        dest_dir=$(dirname "$dest_path")
    fi
    
    if [[ "$needs_sudo" == "true" ]]; then
        if ! sudo mkdir -p "$dest_dir" 2>/dev/null; then
            print_error "No se pudo crear directorio con sudo: $dest_dir"
            log_error "Error creando directorio destino con sudo: $dest_dir"
            return 1
        fi
    else
        if ! mkdir -p "$dest_dir" 2>/dev/null; then
            print_error "No se pudo crear directorio: $dest_dir"
            log_error "Error creando directorio destino: $dest_dir"
            return 1
        fi
    fi
    
    # Crear respaldo (solo si no es root o el usuario puede crear backups)
    if [[ "$needs_sudo" != "true" ]]; then
        create_backup "$dest_path" "$description"
    else
        print_info "Saltando respaldo para configuraci√≥n de root"
    fi
    
    # Crear enlace simb√≥lico
    if [[ -d "$source_path" ]]; then
        # Es un directorio - crear enlace simb√≥lico al directorio
        if [[ "$needs_sudo" == "true" ]]; then
            if sudo ln -sf "$source_path" "$dest_path" 2>/dev/null; then
                print_success "$description enlazada (directorio, root)"
                log_info "Configuraci√≥n de directorio root enlazada exitosamente: $config_name"
            else
                print_error "Error creando enlace de directorio root: $source_path"
                log_error "Error creando enlace de directorio de configuraci√≥n root: $source_path"
                return 1
            fi
        else
            if ln -sf "$source_path" "$dest_path" 2>/dev/null; then
                print_success "$description enlazada (directorio)"
                log_info "Configuraci√≥n de directorio enlazada exitosamente: $config_name"
            else
                print_error "Error creando enlace de directorio: $source_path"
                log_error "Error creando enlace de directorio de configuraci√≥n: $source_path"
                return 1
            fi
        fi
    else
        # Es un archivo - crear enlace simb√≥lico al archivo
        if [[ "$needs_sudo" == "true" ]]; then
            if sudo ln -sf "$source_path" "$dest_path" 2>/dev/null; then
                print_success "$description enlazada (archivo, root)"
                log_info "Configuraci√≥n de archivo root enlazada exitosamente: $config_name"
            else
                print_error "Error creando enlace de archivo root: $source_path"
                log_error "Error creando enlace de archivo de configuraci√≥n root: $source_path"
                return 1
            fi
        else
            if ln -sf "$source_path" "$dest_path" 2>/dev/null; then
                print_success "$description enlazada (archivo)"
                log_info "Configuraci√≥n de archivo enlazada exitosamente: $config_name"
            else
                print_error "Error creando enlace de archivo: $source_path"
                log_error "Error creando enlace de archivo de configuraci√≥n: $source_path"
                return 1
            fi
        fi
    fi
    
    return 0
}

install_selected_configs() {
    local selected_configs=("$@")
    
    if [[ ${#selected_configs[@]} -eq 0 ]]; then
        print_warning "No se seleccionaron configuraciones para instalar"
        return 0
    fi
    
    print_step "INSTALANDO CONFIGURACIONES SELECCIONADAS"
    log_info "Iniciando instalaci√≥n de configuraciones: ${selected_configs[*]}"
    
    local installed=0
    local failed=0
    
    for config in "${selected_configs[@]}"; do
        if [[ -n "${CONFIGS[$config]}" ]]; then
            IFS='|' read -r source dest desc category <<< "${CONFIGS[$config]}"
            
            if install_config "$config" "$SCRIPT_DIR/$source" "$dest" "$desc"; then
                ((installed++))
            else
                ((failed++))
            fi
        else
            print_error "Configuraci√≥n desconocida: $config"
            log_error "Configuraci√≥n no encontrada en definiciones: $config"
            ((failed++))
        fi
    done
    
    print_step "RESULTADO DE INSTALACI√ìN"
    echo -e "‚úÖ Configuraciones instaladas: ${BOLD}$installed${NC}"
    echo -e "‚ùå Errores: ${BOLD}$failed${NC}"
    
    if [[ $failed -eq 0 ]]; then
        print_success "Todas las configuraciones se instalaron correctamente"
        return 0
    else
        print_warning "Se complet√≥ la instalaci√≥n con algunos errores"
        return 1
    fi
}

# ================================
# GESTI√ìN DE CONFIGURACIONES
# ================================
list_available_configs() {
    print_step "CONFIGURACIONES DISPONIBLES"
    
    echo -e "${CYAN}‚îå‚îÄ CONFIGURACIONES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê${NC}"
    
    for config in "${!CONFIGS[@]}"; do
        IFS='|' read -r source dest desc category <<< "${CONFIGS[$config]}"
        # Expandir ~ a la ruta completa del home
        dest="${dest/#\~/$HOME}"
        
        local status="‚ùå No instalado"
        if [[ -f "$dest" || -d "$dest" ]]; then
            if [[ -L "$dest" ]]; then
                status="üîó Enlazado"
            else
                status="‚úÖ Instalado"
            fi
        fi
        
        echo -e "${CYAN}‚îÇ${NC} ${BOLD}$config${NC} - $desc"
        echo -e "${CYAN}‚îÇ${NC}   Destino: $dest"
        echo -e "${CYAN}‚îÇ${NC}   Estado: $status"
        echo -e "${CYAN}‚îÇ${NC}   Categor√≠a: $category"
        echo -e "${CYAN}‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§${NC}"
    done
    
    echo -e "${CYAN}‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò${NC}"
}

get_configs_by_category() {
    local target_category="$1"
    local result=()
    
    for config in "${!CONFIGS[@]}"; do
        IFS='|' read -r source dest desc category <<< "${CONFIGS[$config]}"
        if [[ "$category" == "$target_category" ]]; then
            result+=("$config")
        fi
    done
    
    printf '%s\n' "${result[@]}"
}

check_config_status() {
    local config="$1"
    
    if [[ -z "${CONFIGS[$config]}" ]]; then
        echo "unknown"
        return 1
    fi
    
    IFS='|' read -r source dest desc category <<< "${CONFIGS[$config]}"
    # Expandir ~ a la ruta completa del home
    dest="${dest/#\~/$HOME}"
    
    if [[ -f "$dest" || -d "$dest" ]]; then
        if [[ -L "$dest" ]]; then
            echo "linked"
        else
            echo "installed"
        fi
        return 0
    else
        echo "not_installed"
        return 1
    fi
}

# ================================
# POST-INSTALACI√ìN
# ================================
post_install_tasks() {
    local installed_configs=("$@")
    
    print_step "TAREAS POST-INSTALACI√ìN"
    
    # Verificar si se instal√≥ ZSH o Bash
    local shell_installed=false
    local root_shell_installed=false
    
    for config in "${installed_configs[@]}"; do
        if [[ "$config" == "zsh" || "$config" == "bash" ]]; then
            shell_installed=true
        fi
        if [[ "$config" == "zsh-root" ]]; then
            root_shell_installed=true
        fi
    done
    
    if [[ "$shell_installed" == "true" ]]; then
        print_substep "Configuraci√≥n de shell detectada"
        
        # Sugerir recarga de configuraci√≥n
        if [[ -f "$HOME/.zshrc" && "$SHELL" == *"zsh"* ]]; then
            print_info "Para aplicar la nueva configuraci√≥n de ZSH:"
            echo -e "  ${BOLD}source ~/.zshrc${NC}"
        elif [[ -f "$HOME/.bashrc" && "$SHELL" == *"bash"* ]]; then
            print_info "Para aplicar la nueva configuraci√≥n de Bash:"
            echo -e "  ${BOLD}source ~/.bashrc${NC}"
        fi
        
        # Verificar si el shell actual coincide con la configuraci√≥n
        local current_shell=$(basename "$SHELL")
        if [[ -f "$HOME/.zshrc" && "$current_shell" != "zsh" ]]; then
            print_warning "Se instal√≥ configuraci√≥n de ZSH pero el shell actual es: $current_shell"
            print_info "Para cambiar a ZSH: ${BOLD}chsh -s $(which zsh)${NC}"
        fi
    fi
    
    if [[ "$root_shell_installed" == "true" ]]; then
        print_substep "Configuraci√≥n de ZSH root detectada"
        print_info "Configuraci√≥n de ZSH para root instalada exitosamente"
        print_warning "Para cambiar shell de root a ZSH: ${BOLD}sudo chsh -s $(which zsh) root${NC}"
    fi
    
    # Verificar configuraciones de Starship
    local starship_configs=()
    for config in "${installed_configs[@]}"; do
        if [[ "$config" == "starship" ]]; then
            starship_configs+=("usuario")
        elif [[ "$config" == "starship-root" ]]; then
            starship_configs+=("root")
        fi
    done
    
    if [[ ${#starship_configs[@]} -gt 0 ]]; then
        print_substep "Configuraciones de Starship detectadas"
        for starship_type in "${starship_configs[@]}"; do
            print_info "Starship configurado para: $starship_type"
        done
        
        if ! command_exists starship; then
            print_warning "Starship no est√° instalado. Inst√°lalo con:"
            echo -e "  ${BOLD}sudo pacman -S starship${NC}"
        fi
    fi
    
    # Verificar configuraci√≥n de terminal
    for config in "${installed_configs[@]}"; do
        if [[ "$config" == "kitty" ]]; then
            print_info "Configuraci√≥n de Kitty instalada"
            if command_exists kitty; then
                print_info "Reinicia Kitty para aplicar la nueva configuraci√≥n"
            else
                print_warning "Kitty no est√° instalado. Usa el instalador de herramientas."
            fi
            break
        fi
    done
    
    # Verificar herramientas modernas requeridas
    check_modern_tools_requirements "${installed_configs[@]}"
    
    # Mensaje final
    print_success "Tareas post-instalaci√≥n completadas"
    print_info "Puede ser necesario reiniciar la terminal para aplicar todos los cambios"
}

# ================================
# HERRAMIENTAS MODERNAS
# ================================
check_modern_tools_requirements() {
    local installed_configs=("$@")
    
    # Definir herramientas requeridas por configuraci√≥n
    local -A config_requirements=(
        ["zsh"]="eza,bat,fd,rg,fzf,zoxide,mcfly"
        ["zsh-root"]="eza,bat,fd,rg,fzf,duf,dust,btm,procs"
        ["starship"]="starship"
        ["starship-root"]="starship"
    )
    
    local missing_tools=()
    local suggested_packages=()
    
    for config in "${installed_configs[@]}"; do
        if [[ -n "${config_requirements[$config]}" ]]; then
            IFS=',' read -ra tools <<< "${config_requirements[$config]}"
            for tool in "${tools[@]}"; do
                if ! command_exists "$tool"; then
                    if [[ ! " ${missing_tools[@]} " =~ " ${tool} " ]]; then
                        missing_tools+=("$tool")
                        
                        # Mapear herramientas a paquetes de Arch
                        case "$tool" in
                            "eza") suggested_packages+=("eza") ;;
                            "bat") suggested_packages+=("bat") ;;
                            "fd") suggested_packages+=("fd") ;;
                            "rg") suggested_packages+=("ripgrep") ;;
                            "fzf") suggested_packages+=("fzf") ;;
                            "zoxide") suggested_packages+=("zoxide") ;;
                            "mcfly") suggested_packages+=("mcfly") ;;
                            "duf") suggested_packages+=("duf") ;;
                            "dust") suggested_packages+=("dust") ;;
                            "btm") suggested_packages+=("bottom") ;;
                            "procs") suggested_packages+=("procs") ;;
                            "starship") suggested_packages+=("starship") ;;
                        esac
                    fi
                fi
            done
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        print_substep "Herramientas modernas recomendadas"
        print_warning "Faltan herramientas para funcionalidad completa:"
        
        for tool in "${missing_tools[@]}"; do
            echo -e "  ${YELLOW}‚ó¶${NC} $tool"
        done
        
        if [[ ${#suggested_packages[@]} -gt 0 ]]; then
            print_info "Para instalar todas las herramientas sugeridas:"
            echo -e "  ${BOLD}sudo pacman -S ${suggested_packages[*]}${NC}"
            print_info "O usa la opci√≥n 'Gestionar herramientas' del men√∫ principal"
        fi
    else
        print_success "Todas las herramientas modernas est√°n disponibles"
    fi
}

# ================================
# VALIDACIONES
# ================================
validate_config_source() {
    local config="$1"
    
    if [[ -z "${CONFIGS[$config]}" ]]; then
        return 1
    fi
    
    IFS='|' read -r source dest desc category <<< "${CONFIGS[$config]}"
    local source_path="$SCRIPT_DIR/$source"
    
    if [[ ! -f "$source_path" && ! -d "$source_path" ]]; then
        log_error "Archivo/directorio fuente no encontrado: $source_path"
        return 1
    fi
    
    return 0
}

# Cargar configuraciones al inicializar el m√≥dulo
load_config_definitions